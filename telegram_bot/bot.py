# telegram_bot/bot.py
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters
from config import config
from job_sources.remoteok import RemoteOK

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

class JobBot:
    def __init__(self, token):
        self.application = Application.builder().token(token).build()
        self.job_source = RemoteOK()  # Using RemoteOK as the job source

        self.application.add_handler(CommandHandler("start", self.start))
        self.application.add_handler(CallbackQueryHandler(self.handle_callback_query))
        self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_message))

    def run(self):
        self.application.run_polling()

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        logger.info("Received /start command")
        professions = ['software engineer', 'data scientist', 'devops engineer', 'product manager']

        profession_keyboard = [
            [InlineKeyboardButton(profession.title(), callback_data=f'profession_{profession}')] for profession in professions
        ]

        reply_markup_profession = InlineKeyboardMarkup(profession_keyboard)
        await update.message.reply_text('Select your profession:', reply_markup=reply_markup_profession)

    async def handle_callback_query(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        query = update.callback_query
        await query.answer()

        logger.info(f"Handling callback query: {query.data}")

        if query.data.startswith('profession_'):
            context.user_data['profession'] = query.data.split('_')[1]
            logger.info(f"Selected profession: {context.user_data['profession']}")
            await self.ask_tag_generation_method(update, context)
        elif query.data == 'autogenerate_tags':
            context.user_data['tags_method'] = 'autogenerate'
            await self.autogenerate_tags(update, context)
        elif query.data == 'manual_tags':
            context.user_data['tags_method'] = 'manual'
            await self.manual_tag_entry(update, context)
        elif query.data == 'start_searching':
            await self.start_searching(update, context)

    async def ask_tag_generation_method(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        logger.info("Asking for tag generation method")
        keyboard = [
            [InlineKeyboardButton("Autogenerate Tags", callback_data='autogenerate_tags')],
            [InlineKeyboardButton("Enter Tags Manually", callback_data='manual_tags')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(chat_id=update.effective_chat.id, text='How would you like to enter tags?', reply_markup=reply_markup)

    async def autogenerate_tags(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        logger.info("Autogenerating tags")
        profession = context.user_data.get('profession', 'devops engineer')

        autogenerated_tags = {
            'devops engineer': ['aws', 'docker', 'kubernetes', 'ci/cd', 'terraform', 'linux', 'jenkins', 'ansible'],
            'software engineer': ['python', 'javascript', 'react', 'node.js', 'java', 'c++', 'ruby', 'html/css'],
            'data scientist': ['python', 'pandas', 'machine learning', 'deep learning', 'tensorflow', 'numpy', 'statistics', 'r'],
            'product manager': ['agile', 'scrum', 'product roadmap', 'user stories', 'market research', 'ux/ui', 'business analysis']
        }

        selected_tags = autogenerated_tags.get(profession, [])
        context.user_data['selected_tags'] = set(selected_tags)
        context.user_data['jobs'] = self.job_source.fetch_jobs()

        await context.bot.send_message(chat_id=update.effective_chat.id, text=f"Autogenerated Tags: {', '.join(selected_tags)}")
        await self.display_start_search_button(update, context)

    async def manual_tag_entry(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        logger.info("Entering tags manually")
        await context.bot.send_message(chat_id=update.effective_chat.id, text='Please enter the tags you want to search for, separated by commas.')

    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        user_input = update.message.text
        tags = [tag.strip().lower() for tag in user_input.split(',')]
        context.user_data['selected_tags'] = set(tags)
        context.user_data['jobs'] = self.job_source.fetch_jobs()

        await context.bot.send_message(chat_id=update.effective_chat.id, text=f"Entered Tags: {', '.join(tags)}")
        await self.display_start_search_button(update, context)

    async def display_start_search_button(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        keyboard = [[InlineKeyboardButton("Start Searching", callback_data='start_searching')]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(chat_id=update.effective_chat.id, text='Press "Start Searching" to begin:', reply_markup=reply_markup)

    async def start_searching(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        selected_tags = context.user_data['selected_tags']
        jobs = context.user_data['jobs']
        matching_jobs = [job for job in jobs if selected_tags.intersection(set(job['tags']))]

        if not matching_jobs:
            await update.callback_query.edit_message_text('No job postings found with the selected tags.')
            return

        for job in matching_jobs:
            message = (
                f"Title: {job.get('title', 'N/A')}\n"
                f"Company: {job.get('company', 'N/A')}\n"
                f"Location: {job.get('location', 'N/A')}\n"
                f"Link: {job.get('url', 'N/A')}"
            )
            await context.bot.send_message(chat_id=update.effective_chat.id, text=message)

def main():
    bot = JobBot(config.TELEGRAM_BOT_TOKEN)
    bot.run()

if __name__ == '__main__':
    main()
